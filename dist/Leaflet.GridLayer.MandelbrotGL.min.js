L.GridLayer.MandelbrotGL=L.GridLayer.extend({_vertexShader:"attribute vec2 aVertexPosition;\nattribute highp vec3 aPlotPosition;\nvarying highp vec3 vPosition;\nvoid main(void) {\n	gl_Position = vec4(aVertexPosition, 1.0, 1.0);\n	vPosition = aPlotPosition;\n}",_fragmentShaderMandelbrot:"#version 100\n\nprecision highp float;\n\nvarying highp vec3 vPosition;\n\nint fractal(void) {\n	float cx = vPosition.x;\n	float cy = vPosition.y;\n	float cz = vPosition.z;\n\n	float x = 0.0;\n	float y = 0.0;\n	float tempX = 0.0;\n	int i = 0;\n	int m = 100 + int(cz) * 50;\n	int runaway = 0;\n	for (int i=1; i < 200; i++) {\n		tempX = x * x - y * y + float(cx);\n		y = 2.0 * x * y + float(cy);\n		x = tempX;\n		if (runaway == 0 && x * x + y * y > 100.0) {\n			runaway = i;\n			break;\n		}\n	}\n\n	return runaway;\n}",_fragmentShaderHueRamp:"\nvoid main(void) {\n	int steps = 0;\n	float hue;\n	float saturation;\n	float value;\n	float hueRound;\n	int hueIndex;\n	float f;\n	float p;\n	float q;\n	float t;\n	\n	steps = fractal();\n\n	if (steps != 0) {\n		hue = float(steps) / 200.0;\n		saturation = 0.6;\n		value = 1.0;\n\n		hueRound = hue * 6.0;\n		hueIndex = int(mod(float(int(hueRound)), 6.0));\n		f = fract(hueRound);\n		p = value * (1.0 - saturation);\n		q = value * (1.0 - f * saturation);\n		t = value * (1.0 - (1.0 - f) * saturation);\n\n		if (hueIndex == 0)\n			gl_FragColor = vec4(value, t, p, 1.0);\n		else if (hueIndex == 1)\n			gl_FragColor = vec4(q, value, p, 1.0);\n		else if (hueIndex == 2)\n			gl_FragColor = vec4(p, value, t, 1.0);\n		else if (hueIndex == 3)\n			gl_FragColor = vec4(p, q, value, 1.0);\n		else if (hueIndex == 4)\n			gl_FragColor = vec4(t, p, value, 1.0);\n		else if (hueIndex == 5)\n			gl_FragColor = vec4(value, p, q, 1.0);\n\n	} else {\n		gl_FragColor = vec4(0.0, 0.0, 0.0, 1.0);\n	}\n}",_fragmentShaderBlueRamp:"\nvoid main(void) {\n	int steps = 0;\n	float blue;\n	float yellow;\n	\n	steps = fractal();\n\n	if (steps != 0) {\n		blue = float(steps) / 100.0;\n		yellow = blue / 2.0;\n\n		gl_FragColor = vec4(yellow, yellow, blue, 1.0);\n\n	} else {\n		gl_FragColor = vec4(0.0, 0.0, 0.0, 1.0);\n	}\n}",_fragmentShaderZebraRamp:"\n\nvoid main(void) {\n	int steps = 0;\n	\n	steps = fractal();\n\n	// This is a *very* dirty way of doing modulo 2 operations.\n	// Multiplying a 32-bit integer by 2^31 will effectively \n	//   shift the integer 31 bits and drop the 31 most significant\n	//   bits, leaving only the least significant one.\n	// Then, divide the number by 2^30 to clear the overflow.\n	\n	if ((steps * 2147483648) / 1073741824 != 0) {\n		gl_FragColor = vec4(1.0, 1.0, 1.0, 1.0);\n	} else {\n		gl_FragColor = vec4(0.0, 0.0, 0.0, 1.0);\n	}\n}\n",_fragmentShaderHcl:"\n// This file defines a hcl2rgb transformation, which is used by specific colour ramps.\n\n\n\n#define M_PI 3.1415926535897932384626433832795\n#define M_TAU 2.0 * M_PI\n\n\n// D65 standard referent\n#define lab_X 0.950470\n#define lab_Y 1.0\n#define lab_Z 1.088830\n\nmat4 xyz2rgb = mat4( 3.2404542, -1.5371385, -0.4985314, 0.0,\n                    -0.9692660,  1.8760108,  0.0415560, 0.0,\n                     0.0556434, -0.2040259,  1.0572252, 0.0,\n                     0.0,              0.0,              0.0,             1.0);\n\nfloat lab2xyz(float n) {\n	if (n > 0.00080817591) {// 0.206893034 / 256\n		return pow(n, 3.0);\n	} else {\n		return (n - 0.0005387931) / 0.030418113;	// (x - 4/29) / 7.787037 but in [0..1] instead of [0..256]\n	}\n}\n\nvec4 hcl2rgb(vec4 hclg) {\n	float h = hclg[0];	// Hue\n	float c = hclg[1];	// Chrominance\n	float l = hclg[2];	// Lightness\n	float alpha = hclg[3];	// Alpha\n\n	// First, convert HCL to L*a*b colour space\n	h *= M_TAU; // from 0..1 to 1..2*pi\n	float a = cos(h) * c;\n	float b = sin(h) * c;\n	\n	// L*a*b to XYZ\n	float y = (l + 0.0625) / 0.453126;	// y = (l+16) / 116 but in [0..1] instead of [0..255]\n	float x = y + (a / 1.953125);     	// x = y + (a/500) but in [0..1] instead of [0..255]\n	float z = y - (b / 0.78125);      	// z = y - (b/200) but in [0..1] instead of [0..255]\n	\n	x = lab2xyz(x) * lab_X;\n	y = lab2xyz(y) * lab_Y;\n	z = lab2xyz(z) * lab_Z;\n	\n	return vec4(x, y, z, alpha) * xyz2rgb;\n}\n\n",_fragmentShaderHclHue:"\nvoid main(void) {\n	int steps = 0;\n	\n	steps = fractal();\n\n	if (steps > 0) {\n		float hue    = float(steps) / 25.0;\n		float light = 0.2 + float(steps) / 1000.0;\n		float chroma = clamp(float(steps) / 300.0, 0.3, 0.7);\n		\n		gl_FragColor = hcl2rgb( vec4(hue, chroma, light, 1.0) );\n	} else {\n		gl_FragColor = vec4(0.0, 0.0, 0.0, 1.0);\n	}\n}\n",_fragmentShaderHclBlue:"\nvoid main(void) {\n	int steps = 0;\n	\n	steps = fractal();\n\n	if (steps > 0) {\n		float hue    = 0.7 + float(steps) / 2000.0;\n		float light  = 0.15 + float(steps) / 400.0;\n		float chroma = float(steps) / 200.0;\n		\n		gl_FragColor = hcl2rgb( vec4(hue, chroma, light, 1.0) );\n	} else {\n		gl_FragColor = vec4(0.0, 0.0, 0.0, 1.0);\n	}\n}\n",options:{maxZoom:22,colorRamp:"hue",fractal:"mandelbrot"},initialize:function(e){e=L.setOptions(this,e),this._renderer=L.DomUtil.create("canvas"),this._renderer.width=this._renderer.height=this.options.tileSize;var n=this._gl=this._renderer.getContext("experimental-webgl");n.viewportWidth=this.options.tileSize,n.viewportHeight=this.options.tileSize,this._loadGLProgram(),this._vertexBuffer=n.createBuffer(),n.bindBuffer(n.ARRAY_BUFFER,this._vertexBuffer);var t=[1,1,-1,1,1,-1,-1,-1];n.bufferData(n.ARRAY_BUFFER,new Float32Array(t),n.STATIC_DRAW),this._vertexBuffer.itemSize=2,this._vertexBuffer.numItems=4,n.bindBuffer(n.ARRAY_BUFFER,this._vertexBuffer),n.vertexAttribPointer(this._aVertexPosition,this._vertexBuffer.itemSize,n.FLOAT,!1,0,0)},_loadGLProgram:function(e,n){var t=this._gl,a=this._fragmentShaderHueRamp;"blue"==this.options.colorRamp?a=this._fragmentShaderBlueRamp:"zebra"==this.options.colorRamp?a=this._fragmentShaderZebraRamp:"hclhue"==this.options.colorRamp?a=this._fragmentShaderHcl+this._fragmentShaderHclHue:"hclblue"==this.options.colorRamp&&(a=this._fragmentShaderHcl+this._fragmentShaderHclBlue);var r=this._fragmentShaderMandelbrot,o=t.createProgram(),i=t.createShader(t.VERTEX_SHADER),l=t.createShader(t.FRAGMENT_SHADER);return t.shaderSource(i,this._vertexShader),t.shaderSource(l,r+a),t.compileShader(i),t.compileShader(l),t.getShaderParameter(i,t.COMPILE_STATUS)?t.getShaderParameter(l,t.COMPILE_STATUS)?(t.attachShader(o,i),t.attachShader(o,l),t.linkProgram(o),t.useProgram(o),this._aVertexPosition=t.getAttribLocation(o,"aVertexPosition"),t.enableVertexAttribArray(this._aVertexPosition),this._aPlotPosition=t.getAttribLocation(o,"aPlotPosition"),void t.enableVertexAttribArray(this._aPlotPosition)):(console.error(t.getShaderInfoLog(l)),null):(console.error(t.getShaderInfoLog(i)),null)},_render:function(e){var n,t=this._gl;corners=[];var a=[[.5,.5],[-.5,.5],[.5,-.5],[-.5,-.5]],r=Math.pow(2,e.z),o=(e.x+.5)/r,i=(e.y+.5)/r;for(n in a)x=a[n][0],y=a[n][1],corners.push(x/r+o),corners.push(y/r-i),corners.push(r);var l=t.createBuffer();t.bindBuffer(t.ARRAY_BUFFER,l),t.bufferData(t.ARRAY_BUFFER,new Float32Array(corners),t.STATIC_DRAW),t.vertexAttribPointer(this._aPlotPosition,3,t.FLOAT,!1,0,0),t.drawArrays(t.TRIANGLE_STRIP,0,4),t.deleteBuffer(l)},createTile:function(e,n){var t=L.DomUtil.create("canvas","leaflet-tile");t.width=t.height=this.options.tileSize,t.onselectstart=t.onmousemove=L.Util.falseFn;var a=t.getContext("2d");return this._render(e),a.drawImage(this._renderer,0,0),L.DomUtil.addClass(t,"leaflet-tile-loaded"),t},setColorRamp:function(e){this.options.colorRamp=e,this._loadGLProgram(),this.redraw()}}),L.gridLayer.mandelbrotGL=function(e){return new L.GridLayer.MandelbrotGL(e)};
//# sourceMappingURL=Leaflet.GridLayer.MandelbrotGL.min.js.map
