{"version":3,"file":"Leaflet.GridLayer.MandelbrotGL.min.js","sources":["../src/Leaflet.GridLayer.MandelbrotGL.js"],"sourcesContent":["\nL.GridLayer.MandelbrotGL = L.GridLayer.extend({\n\n\t// The vertex shader does pretty much nothing, as every render\n\t//   uses the same quadrilateral spanning the entire GL viewport\n\t//   coordinate space. The coordinates of the tile corners are\n\t//   passed through to the fragment shader.\n\t// Note that the source is in the shaders/ directory and will\n\t//   get included here with some gobblejs magic.\n\t_vertexShader: <@simple_vertex_shader@>,\n\n\t// The fragment shader is where the magic happens. Based on \n\t//   the coordinates of the four corners, it interpolates the \n\t//   complex plane coordinates for every pixel to be rendered,\n\t//   and performs the calculations unsing 200 steps and a threshold\n\t//   of 10; then it maps the steps to a color using a hue scale.\n\t// The code is pretty much inspired by http://learningwebgl.com/lessons/example01/\n\t//\n\t// Note that the source is in the shaders/ directory and will\n\t//   get included here with some gobblejs magic.\n\t//\n\t// TODO: Implement double floating precision as per \n\t//   https://www.thasler.com/blog/blog/glsl-part2-emu\n\t_fragmentShaderMandelbrot: <@fragment_shader_mandelbrot@>,\n\t_fragmentShaderHueRamp:    <@fragment_shader_hue_ramp@>,\n\t_fragmentShaderBlueRamp:   <@fragment_shader_blue_ramp@>,\n\t_fragmentShaderZebraRamp:  <@fragment_shader_zebra_ramp@>,\n\t_fragmentShaderHcl:        <@fragment_shader_hcl@>,\n\t_fragmentShaderHclHue:     <@fragment_shader_hcl_hue@>,\n\t_fragmentShaderHclBlue:    <@fragment_shader_hcl_blue@>,\n\n\toptions: {\n\t\tmaxZoom: 22,\n\t\tcolorRamp: 'hue',\n\t\tfractal: 'mandelbrot'\n\t},\n\n\t\n\t// On instantiating the layer, it will initialize all the GL context\n\t//   and upload the shaders to the GPU, along with the vertex buffer\n\t//   (the vertices will stay the same for all tiles).\n\tinitialize: function(options) {\n\t\toptions = L.setOptions(this, options);\n\n\t\tthis._renderer = L.DomUtil.create('canvas');\n\t\tthis._renderer.width = this._renderer.height = this.options.tileSize;\n\n\t\tvar gl = this._gl = this._renderer.getContext(\"experimental-webgl\");\n\t\tgl.viewportWidth  = this.options.tileSize;\n\t\tgl.viewportHeight = this.options.tileSize;\n\n\t\tthis._loadGLProgram()\n\n\t\tthis._vertexBuffer = gl.createBuffer();\n\t\tgl.bindBuffer(gl.ARRAY_BUFFER, this._vertexBuffer);\n\t\tvar vertices = [\n\t\t\t 1.0,  1.0,\n\t\t\t-1.0,  1.0,\n\t\t\t 1.0, -1.0,\n\t\t\t-1.0, -1.0,\n\t\t];\n\t\tgl.bufferData(gl.ARRAY_BUFFER, new Float32Array(vertices), gl.STATIC_DRAW);\n\t\tthis._vertexBuffer.itemSize = 2;\n\t\tthis._vertexBuffer.numItems = 4;\n\n\t\tgl.bindBuffer(gl.ARRAY_BUFFER, this._vertexBuffer);\n\t\tgl.vertexAttribPointer(this._aVertexPosition, this._vertexBuffer.itemSize, gl.FLOAT, false, 0, 0);\n\t},\n\n\t\n\t_loadGLProgram: function(fractal, ramp) {\n\t\tvar gl = this._gl;\n\t\t\n\t\tvar colouringFragment = this._fragmentShaderHueRamp;\t// Default\n\t\tif (this.options.colorRamp == 'blue') {\n\t\t\tcolouringFragment = this._fragmentShaderBlueRamp;\n\t\t} else if (this.options.colorRamp == 'zebra') {\n\t\t\tcolouringFragment = this._fragmentShaderZebraRamp;\n\t\t} else if (this.options.colorRamp == 'hclhue') {\n\t\t\tcolouringFragment = this._fragmentShaderHcl + this._fragmentShaderHclHue;\n\t\t} else if (this.options.colorRamp == 'hclblue') {\n\t\t\tcolouringFragment = this._fragmentShaderHcl + this._fragmentShaderHclBlue;\n\t\t}\n\t\t\n\t\tvar fractalFragment = this._fragmentShaderMandelbrot;\n\t\t\n\t\t\n\t\tvar program = gl.createProgram();\n\t\tvar vertexShader   = gl.createShader(gl.VERTEX_SHADER);\n\t\tvar fragmentShader = gl.createShader(gl.FRAGMENT_SHADER);\n\t\tgl.shaderSource(vertexShader, this._vertexShader);\n\t\tgl.shaderSource(fragmentShader, fractalFragment + colouringFragment);\n\t\tgl.compileShader(vertexShader);\n\t\tgl.compileShader(fragmentShader);\n\t\tif (!gl.getShaderParameter(vertexShader, gl.COMPILE_STATUS)) {\n\t\t\tconsole.error(gl.getShaderInfoLog(vertexShader));\n\t\t\treturn null;\n\t\t}\n\t\tif (!gl.getShaderParameter(fragmentShader, gl.COMPILE_STATUS)) {\n\t\t\tconsole.error(gl.getShaderInfoLog(fragmentShader));\n\t\t\treturn null;\n\t\t}\n\t\tgl.attachShader(program, vertexShader);\n\t\tgl.attachShader(program, fragmentShader);\n\t\tgl.linkProgram(program);\n\t\tgl.useProgram(program);\n\t\t\n\t\tthis._aVertexPosition = gl.getAttribLocation(program, \"aVertexPosition\");\n\t\tgl.enableVertexAttribArray(this._aVertexPosition);\n\t\tthis._aPlotPosition = gl.getAttribLocation(program, \"aPlotPosition\");\n\t\tgl.enableVertexAttribArray(this._aPlotPosition);\n\n\t\t\n\t},\n\t\n\t\n\t// This is called once per tile - uses the layer's GL context to\n\t//   render a tile, passing the complex space coordinates to the\n\t//   GPU, and asking to render the vertexes (as triangles) again.\n\t// Every pixel will be opaque, so there is no need to clear the scene.\n\t_render: function(coords) {\n\t\tvar gl = this._gl;\n\n\t\t// Calculate complex space coordinates of the corners...\n\t\tvar cornerIx;\n\t\tcorners = [];\n\t\tvar baseCorners = [\n\t\t\t[ 0.5,  0.5],\n\t\t\t[-0.5,  0.5],\n\t\t\t[ 0.5, -0.5],\n\t\t\t[-0.5, -0.5],\n\t\t];\n\t\tvar z = Math.pow(2, coords.z);\n\n\t\tvar tileCenterX = (coords.x + 0.5 )/z;\n\t\tvar tileCenterY = (coords.y + 0.5 )/z;\n\n\t\tfor (cornerIx in baseCorners) {\n\t\t\tx = baseCorners[cornerIx][0];\n\t\t\ty = baseCorners[cornerIx][1];\n\t\t\tcorners.push(x/z + tileCenterX);\n\t\t\tcorners.push(y/z - tileCenterY);\n\t\t\tcorners.push(z);\n\t\t}\n\n\t\t// ...upload them to the GPU...\n\t\tvar plotPositionBuffer = gl.createBuffer();\n\t\tgl.bindBuffer(gl.ARRAY_BUFFER, plotPositionBuffer);\n\t\tgl.bufferData(gl.ARRAY_BUFFER, new Float32Array(corners), gl.STATIC_DRAW);\n\t\tgl.vertexAttribPointer(this._aPlotPosition, 3, gl.FLOAT, false, 0, 0);\n\n\t\t// ... and then the magic happens.\n\t\tgl.drawArrays(gl.TRIANGLE_STRIP, 0, 4);\n\n\t\tgl.deleteBuffer(plotPositionBuffer);\n\t},\n\n\tcreateTile: function (coords, done) {\n\t\tvar tile = L.DomUtil.create('canvas', 'leaflet-tile');\n\t\ttile.width = tile.height = this.options.tileSize;\n\t\ttile.onselectstart = tile.onmousemove = L.Util.falseFn;\n\n\t\tvar ctx = tile.getContext('2d');\n\t\tthis._render(coords);\n\t\tctx.drawImage(this._renderer, 0, 0);\n\n\t\tL.DomUtil.addClass(tile, 'leaflet-tile-loaded');\n\n\t\treturn tile;\n\t},\n\t\n\tsetColorRamp: function(ramp) {\n\t\tthis.options.colorRamp = ramp;\n\t\tthis._loadGLProgram();\n\t\tthis.redraw();\n\t}\n\n});\n\n\nL.gridLayer.mandelbrotGL = function (options) {\n\treturn new L.GridLayer.MandelbrotGL(options);\n};\n"],"names":["L","GridLayer","MandelbrotGL","extend","_vertexShader","_fragmentShaderMandelbrot","_fragmentShaderHueRamp","_fragmentShaderBlueRamp","_fragmentShaderZebraRamp","_fragmentShaderHcl","_fragmentShaderHclHue","_fragmentShaderHclBlue","options","maxZoom","colorRamp","fractal","initialize","setOptions","this","_renderer","DomUtil","create","width","height","tileSize","gl","_gl","getContext","viewportWidth","viewportHeight","_loadGLProgram","_vertexBuffer","createBuffer","bindBuffer","ARRAY_BUFFER","vertices","bufferData","Float32Array","STATIC_DRAW","itemSize","numItems","vertexAttribPointer","_aVertexPosition","FLOAT","ramp","colouringFragment","fractalFragment","program","createProgram","vertexShader","createShader","VERTEX_SHADER","fragmentShader","FRAGMENT_SHADER","shaderSource","compileShader","getShaderParameter","COMPILE_STATUS","attachShader","linkProgram","useProgram","getAttribLocation","enableVertexAttribArray","_aPlotPosition","console","error","getShaderInfoLog","_render","coords","cornerIx","corners","baseCorners","z","Math","pow","tileCenterX","x","tileCenterY","y","push","plotPositionBuffer","drawArrays","TRIANGLE_STRIP","deleteBuffer","createTile","done","tile","onselectstart","onmousemove","Util","falseFn","ctx","drawImage","addClass","setColorRamp","redraw","gridLayer","mandelbrotGL"],"mappings":"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"}